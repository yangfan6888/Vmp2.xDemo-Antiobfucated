假如算push一个常量(push 0x62340CC6)为vmp接手起点，
单步跟踪获得下图堆栈

xxxxxxxxxx14FCD0            			RDI指向这里，MOV QWORD PTR DS:[RAX+RDI*1], RDX，RAX每次会变




000000000014FE10   000030AA3557757A       
000000000014FE18   0000000000000000     rflags? RBP指向这里
000000000014FE20   0000000000000000     (0x140009443指令地址push的一个常数)  
000000000014FE28   0000000000000000     R12  
000000000014FE30   0000000000000000     R9
000000000014FE38   0000000000000000     R15  
000000000014FE40   000000000014FDC0     R11
000000000014FE48   00000000005E78C0     RBX
000000000014FE50   00000000FFFFFFFF     RCX  	
000000000014FE58   0       				RBP
000000000014FE60   2					R14       
000000000014FE68   0000000000000000     R8
000000000014FE70   0000000000000000		RBP       
000000000014FE78   0					RSI  
000000000014FE80   00000000005E13C0     RDI 
000000000014FE88   0000000000000000     R13          
000000000014FE90   00007FFB0CC7B750	    RDX       
000000000014FE98   1					R10       
000000000014FEA0   12					RAX       
000000000014FEA8   206 					RFLAGS     
000000000014FEB0   0xFFFFFFFFCF3E4503   这个地方存着用户函数的真实RIP，上面存放着调用这个地方代码时候的需要的寄存器环境      
000000000014FEB8   0000000062340CC6    （key）      





vmp key解密步骤

MOV     ESI, DWORD PTR SS:[RSP+0xA0] ;ESI = Key
ROL     ESI, 0xA
ADD     ESI, 0xAFEB6683
XOR     ESI, 0xC01E26E9
MOV     RBP, RSP

//循环读取opcode的地方
0000000140008934   | 8A46 FF                | MOV     AL, BYTE PTR DS:[RSI-0x1]             |

vRip = 14000a68e,测试rsi等于在这个vRip的时候，执行我们的代码

//这个像是把返回值放在堆栈上
0000000140006FCE   | 48:891438              | MOV     QWORD PTR DS:[RAX+RDI], RDX           |



每次进handler的时候，RDX为handler地址，

0000000140007534   | 48:8B55 00            | MOV     RDX, QWORD PTR SS:[RBP]               |

RSI在14000A68E的时候触发我们的硬件断点，也就是这个handler会执行我们的mov rax,2222h
对应的vmp handler地址14000784F




