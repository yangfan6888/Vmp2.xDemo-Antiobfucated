000000000014FE48   0000000000000000       
000000000014FE50   0000000000000000       
000000000014FE58   0000000000000000       
000000000014FE60   0000000000000000       
000000000014FE68   0000000000000000       
000000000014FE70   0000000000000000       
000000000014FE78   0000000000000000       
000000000014FE80   0000000000000000       
000000000014FE88   0000000000000000       
000000000014FE90   0000000000000000 RAX      
000000000014FE98   0000000000000000 RCX      
000000000014FEA0   0000000000000000 R11      
000000000014FEA8   0000000000000000 R15      
000000000014FEB0   0000000000000000 RBX      
000000000014FEB8   0000000000000000 R9      
000000000014FEC0   0000000000000000 R13      
000000000014FEC8   0000000000000000 RSI      
000000000014FED0   0000000000000000 R14      
000000000014FED8   0000000000000000 R8
000000000014FEE0   0000000000000000 Rflags      
000000000014FEE8   0000000000000000 R12      
000000000014FEF0   0000000000000000 R10      
000000000014FEF8   0000000000000000 RDX      
000000000014FF00   0000000000000000 RDI      
000000000014FF08   00000001401BC77A RAX      
000000000014FF10   000000014019E872 RBP      
000000000014FF18   000000014019E872 push-call的下一句地址     
000000000014FF20   FFFFFFFF905DF047       


vmp3虽然也是push call进入，但是他这个call不是虚拟机总入口，而是他娘的会不断的push一个不同的key，再调用这个相同的call。

vmp2的r12指向dispatch table，现在vmp3开始没有了，由key算出来的是一个偏移，偏移加上解密代码段基址(loc_1401E136A)是真正的handler地址。
也就是vmp3取消了明显的dispatch table，静态分析变得更困难了。

从入口点开始仿真，可以获得如下的dispatch handler
disp handler = 1401029f8
disp handler = 1401c6638
disp handler = 1401df40e
disp handler = 1401e4cc7
disp handler = 1401c6638
disp handler = 1401a1a49
disp handler = 1401df40e
disp handler = 14019d198
disp handler = 1401a55f9
disp handler = 1401029f8
disp handler = 1401a4e12